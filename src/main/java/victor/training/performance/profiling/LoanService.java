package victor.training.performance.profiling;

import com.zaxxer.hikari.HikariDataSource;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import victor.training.performance.profiling.dto.CommentDto;
import victor.training.performance.profiling.dto.LoanApplicationDto;
import victor.training.performance.profiling.entity.Audit;
import victor.training.performance.profiling.entity.LoanApplication;
import victor.training.performance.profiling.entity.LoanApplication.Status;
import victor.training.performance.profiling.repo.AuditRepo;
import victor.training.performance.profiling.repo.LoanApplicationRepo;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
@RequiredArgsConstructor
//@Transactional // or @TransactionalAttribute (JEE) Transaction on class level is not recommended because it can lead to deadlocks and performance issues
public class LoanService {
  private final LoanApplicationRepo loanApplicationRepo;
  private final CommentsApiClient commentsApiClient;
  private final HikariDataSource dataSource;



  //1) Avoid doing API calls (REST/SOAP/COBOL) while holding a DB transaction/Connection
  //because connection are a scare  precious resource and should be released as soon as possible
//  @Transactional // I don't really need  Tx here since I'm just SELECTing data
  // The Transactional annotation is used to indicate that a method is a transactional method but if use only to get data from the database, it is not necessary to use it
  //because the method is read-only and the transaction is not necessary, and it aquires a connection to the database and it is not necessary
  // getConnection from the database pool
//  the issue here is that the connections were held for a long time and the pool was exhausted
//  issue=connection pool starvation issue; because of unfair usage. the code make Bad use of connection.
//  fix: release the connection faster back to the pool
  public LoanApplicationDto getLoanApplication(Long loanId) {
    List<CommentDto> comments = commentsApiClient.fetchComments(loanId); // takes Â±40ms in prod //60% of time
    LoanApplication loanApplication = loanApplicationRepo.findByIdLoadingSteps(loanId);//44% of time
    LoanApplicationDto dto = new LoanApplicationDto(loanApplication, comments);

    //if (log.isTraceEnabled()) // THE HALLMARK OF LEGACY CODE
    // Today it's generally enough to do use {} in log statements:
//    log.trace(()->"Loan app: " + loanApplication);
//    log.atDebug().addArgument(()->toJson(loanApplication)).log("Loan app: {}");
//    log.debug("Loan app: {}", ()->toJson(loanApplication));
    log.trace("Loan app: {}", loanApplication);// 10% of time LoanApplication.toString() is called here generated by Lombok
// to include all its fields. Some are collections that have to be LAZY-LOADED just for the toString!!!!!!!
    // Fun fact: I don't even see this log since it's on TRACE level
    // how to fix: release the connection faster back to the pool
    return dto;
  }

  private final AuditRepo auditRepo;
  @Transactional // needed hereðŸ’–
  public void saveLoanApplication(String title) {
    Long id = loanApplicationRepo.save(new LoanApplication().setTitle(title)).getId();
    auditRepo.save(new Audit("Loan created: " + id));
  }
  // a) never use Vector, it's bad performance on large sizes
  // b) instead use:
//  private final List<Long> recentLoanStatusQueried = Collections.synchronizedList(new ArrayList<>());

  private final List<Long> recentLoanStatusQueried = new ArrayList<>();
  public synchronized void deadlock() {
    // requires a conn:
    var a = loanApplicationRepo.findById(1L).orElseThrow();
  }

  // 2) don't combine @Transactional (keeping connections open) with synchronized// wasteful(JDBC pool starvation) and risky (deadlocks)
  //  // @Transactional // makes a magic proxy acquire 1 connection from JDBC pool and keep it until the method ends
  // we do here a select from the database and we don't need to use the transactional annotation
  // Transactional and synchronized are not recommended to be used together because they can lead to deadlocks and performance issues



  public synchronized Status getLoanStatus(Long loanId) {
    LoanApplication loanApplication = loanApplicationRepo.findById(loanId).orElseThrow();
      recentLoanStatusQueried.remove(loanId); // BUG#7235 - avoid duplicates in list
      recentLoanStatusQueried.add(loanId);
      while (recentLoanStatusQueried.size() > 10) recentLoanStatusQueried.remove(0);
    return loanApplication.getCurrentStatus();
  }



  private final ThreadPoolTaskExecutor executor;

  @Transactional
  public List<Long> getRecentLoanStatusQueried() {
    log.info("In parent thread");
    CompletableFuture.runAsync(() -> log.info("In a child thread"), executor).join();
    synchronized (recentLoanStatusQueried) {
      return new ArrayList<>(recentLoanStatusQueried);
    }
  }

}
